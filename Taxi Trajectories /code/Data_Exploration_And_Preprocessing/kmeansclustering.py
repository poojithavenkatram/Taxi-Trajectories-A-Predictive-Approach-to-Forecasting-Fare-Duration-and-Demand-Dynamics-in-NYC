# -*- coding: utf-8 -*-
"""KMeansClustering.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tDiM9QkHk6jU8psyvRW_G5WuiKVNg-iZ
"""

!pip install holoviews bokeh dask datashader

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.cluster import KMeans
from holoviews.operation.datashader import datashade, dynspread
import holoviews as hv
from colorcet import fire
import itertools
import math

# Base styles and settings
sns.set_context("paper")
hv.extension('bokeh')


class KMeansClustering:
    def __init__(self, path):
        self.path = path
        self.data = None
        self.NYC_bounds = ((-74.05, -73.7), (40.6, 40.9))
        self.no_classes = 12
        self.pickup_clusters_dict = {}
        self.dropoff_clusters_dict = {}
        self.mean_distances = {}

    def load_and_prepare_data(self):
        df = pd.read_parquet(self.path)
        df['tpep_pickup_datetime'] = pd.to_datetime(df['tpep_pickup_datetime'])
        df['tpep_dropoff_datetime'] = pd.to_datetime(df['tpep_dropoff_datetime'])

        self.data = df[
            ['passenger_count', 'trip_distance', 'pickup_longitude', 'pickup_latitude',
             'dropoff_longitude', 'dropoff_latitude', 'tpep_pickup_datetime', 'tpep_dropoff_datetime']
        ]
        self.data['trip_duration_mins'] = (self.data['tpep_dropoff_datetime'] - self.data['tpep_pickup_datetime']).dt.seconds / 60
        self.filter_data()

    def filter_data(self):
        self.data = self.data[
            (self.data['pickup_longitude'] > -74.05) & (self.data['pickup_longitude'] < -73.75) &
            (self.data['pickup_latitude'] > 40.6) & (self.data['pickup_latitude'] < 40.9) &
            (self.data['dropoff_longitude'] > -74.05) & (self.data['dropoff_longitude'] < -73.75) &
            (self.data['dropoff_latitude'] > 40.6) & (self.data['dropoff_latitude'] < 40.9) &
            (self.data['trip_distance'] < 25) & (self.data['trip_duration_mins'] < 100)
        ]

    def plot_distributions(self):
        sns.displot(self.data[(self.data['pickup_longitude'] > -74.05) & (self.data['pickup_longitude'] < -73.75)]['pickup_longitude'], kde=True)
        plt.xlabel('Pickup Longitude')
        plt.title('Distribution of Pickup Longitude')
        plt.show()

        sns.displot(self.data[(self.data['dropoff_longitude'] > -74.05) & (self.data['dropoff_longitude'] < -73.75)]['dropoff_longitude'], kde=True)
        plt.xlabel('Dropoff Longitude')
        plt.title('Distribution of Dropoff Longitude')
        plt.show()

        sns.displot(self.data[(self.data['pickup_latitude'] > 40.6) & (self.data['pickup_latitude'] < 40.9)]['pickup_latitude'], kde=True)
        plt.xlabel('Pickup Latitude')
        plt.title('Distribution of Pickup Latitude')
        plt.show()

    def visualize_pickups(self):
        points = hv.Points(self.data, kdims=['pickup_longitude', 'pickup_latitude'], vdims=['passenger_count'])
        shaded_points = datashade(points, cmap=fire, width=700, height=500)
        spreaded_points = dynspread(shaded_points, threshold=0.5, max_px=4)
        return spreaded_points

    def cluster_and_plot(self):
        X1 = self.data[['pickup_longitude', 'pickup_latitude']].values
        est_pickup = KMeans(n_clusters=self.no_classes)
        est_pickup.fit(X1)
        self.data['pickup_cluster'] = est_pickup.labels_

        fig, ax = plt.subplots(figsize=(8, 6))
        ax.scatter(X1[:, 0], X1[:, 1], c=est_pickup.labels_.astype(np.float64), marker='o')
        ax.set_xlabel('Longitude')
        ax.set_ylabel('Latitude')
        plt.show()

        X2 = self.data[['dropoff_longitude', 'dropoff_latitude']].values
        est_dropoff = KMeans(n_clusters=self.no_classes)
        est_dropoff.fit(X2)
        labels = est_dropoff.labels_
        self.data['dropoff_cluster'] = labels

        fig, ax = plt.subplots(figsize=(8, 6))
        scatter = ax.scatter(X2[:, 0], X2[:, 1], c=labels.astype(np.float64), marker='o', cmap='viridis')
        ax.set_xlabel('Longitude')
        ax.set_ylabel('Latitude')
        legend1 = ax.legend(*scatter.legend_elements(), loc="upper right", title="Clusters")
        ax.add_artist(legend1)
        plt.show()

    def calculate_cluster_coordinates(self):
        for p in self.data['pickup_cluster'].unique():
            filtered = self.data[self.data['pickup_cluster'] == p]
            mean_longitude = filtered['pickup_longitude'].mean()
            mean_latitude = filtered['pickup_latitude'].mean()
            self.pickup_clusters_dict[p] = (mean_longitude, mean_latitude)

        for d in self.data['dropoff_cluster'].unique():
            filtered = self.data[self.data['dropoff_cluster'] == d]
            mean_longitude = filtered['dropoff_longitude'].mean()
            mean_latitude = filtered['dropoff_latitude'].mean()
            self.dropoff_clusters_dict[d] = (mean_longitude, mean_latitude)

    def calculate_mean_distances(self):
        def haversine(lon1, lat1, lon2, lat2):
            lon1, lat1, lon2, lat2 = map(math.radians, [lon1, lat1, lon2, lat2])
            dlon = lon2 - lon1
            dlat = lat2 - lat1
            a = math.sin(dlat / 2) ** 2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2) ** 2
            c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
            r = 6371
            return c * r

        for dropoff_cluster, pickup_cluster in itertools.product(self.dropoff_clusters_dict, self.pickup_clusters_dict):
            dropoff_coords = self.dropoff_clusters_dict[dropoff_cluster]
            pickup_coords = self.pickup_clusters_dict[pickup_cluster]
            distance = haversine(*dropoff_coords, *pickup_coords)
            self.mean_distances[(dropoff_cluster, pickup_cluster)] = distance

        print("Mean Distances Between Clusters:")
        for clusters, distance in self.mean_distances.items():
            print(clusters, ":", distance)


# Calling the functions
if __name__ == "__main__":
    path = '/app/full_df.parquet'
    analyzer = KMeansClustering(path)
    analyzer.load_and_prepare_data()
    analyzer.plot_distributions()
    analyzer.cluster_and_plot()
    analyzer.calculate_cluster_coordinates()
    analyzer.calculate_mean_distances()